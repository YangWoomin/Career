# CareerDescription

#### 업무(프로젝트)명 : 프리스타일 풋볼 

#### 수행기간 : 2017-01 ~ 2018-12 

#### 수행직무 : 서버 

#### 주요역할 : 라이브 서비스, 컨텐츠 개발, 유지 보수 

#### 세부내용

##### 1. 라이브 서비스
###### 1.1 일단위 서버 모니터링 
* 서버 상태와 텍스트 로그 확인
2) PM/GM CS 업무 지원
- DB 로그 확인과 보상 지급 등
3) 월단위 서버 패치 
- 개발 컨텐츠 적용과 버그 수정 적용, 보상 지급 등
2. 컨텐츠 개발 
1) 신규 컨텐츠 및 이벤트 구현 
- VS C/C++ 2008 2015, MSSQL 2008
- 카드 시스템, 클럽 게시판, 보옥 시스템, 일일 초기화 모듈, 관전 시스템 등
- 빙고 이벤트 외 각종 이벤트 10종 이상
2) PM/GM 운영툴 지원
3) 웹 연동
3. 유지 보수
1) 기존 컨텐츠 보완 및 수정 
- 구조 변경과 버그 수정, 확장성 제공, 재사용 등
2) IDC 및 클라우드 기반 서버 운용
- IDC (중국)
- 베이징 쥬오 (중국)
- 알리 클라우드 (중국)
- AWS (한국, 아시아, 유럽, 남미, 북미)
3) 스마일게이트 PC방 사업 SDK 연동
- 기존 특정 서버 구조 개편, SDK 연동
4) 서버 크래쉬 분석, 예외 처리, 근본적인 원인 분석
- 크래쉬 프로파일링 (WinDbg, VS), 예외 처리 (VS C/C++ SEH)

구체적인 경험과 경력을 전달하기 위해 풀어 쓰는 점 양해 부탁 드립니다.

때는 2017년 1월 9일. 다가오는 대학교 졸업을 앞두고 꿈만 같았던 게임 서버 프로그래머로서 첫 회사에 출근하는 날이었습니다. 신입 신분으로 도전하기에는 분야가 어렵고 진입 장벽이 높은 편이지만 항상 서비스를 해야 하고 대량의 클라이언트 요청을 처리하여 최고의 퍼포먼스를 내야 한다는 서버만의 매력에 사로잡혀서 뛰어들지 않았나 싶습니다.

입사 당시 IOCP조차 몰랐던 저는 3개월 수습 과제로 IOCP를 사용한 채팅 프로그램을 만들었습니다. 현재 다루고 있는 서버의 엔진도 IOCP를 기반으로 구현되어 있어서 꼭 숙지해야 할 개념이었습니다. 그 때 만들었던 채팅 프로그램을 지금 돌이켜 생각해보면 썩 좋은 구조가 아니라는 생각이 들지만 적극적으로 임하는 자세와 끝까지 해내려는 모습을 보고 정식 사원으로 받아 준 것이라 생각합니다.

신입은 보통 최소 6개월에서 1년까지 신입 교육 및 코드 리뷰를 통해 프로젝트를 파악하는 것으로 알고 있습니다. 하지만 제가 속한 팀은 라이브 팀답게 수습 기간 종료와 동시에 실무에 투입되었습니다. 불쑥불쑥 올라오는 라이브 이슈와 CS들이 저에게 조금씩 넘어오기 시작했고 숨이 턱턱 막히는 부담감을 안고 꾸역꾸역 처리해 나가기 시작했습니다. 지금 하면 1시간도 안 걸릴 일을 (자처한) 야근까지 하면서 필사적으로 수행했습니다. 사실 야근은 입사 3일차부터 시작했고 저의 1년차 근무 시간을 보면 회사에서도 거의 상위급에 속할 정도로 많이 했습니다. (자랑은 아니고 그만큼 저의 성장을 위해서 제 나름 투자한 것이라 생각합니다.) 그 때 당시나 지금이나 그렇게 부담되었던 라이브 이슈와 CS들을 전혀 부정적으로 생각하지 않습니다. 소스 파악에 엄청난 도움을 준 것이 사실이고 지금의 강력한 제가 있게 해준 원동력이라 볼 수 있기 때문입니다.

그렇게 조금씩 프로젝트에 친숙해져 가면서 5월부터 신규 컨텐츠 개발을 하기 시작했습니다. 초창기 만든 컨텐츠 중에 가장 기억에 남는 것이 카드 시스템입니다. 계정에 속한 여러 캐릭터 별로 장착(카드 효과 부여)할 수 있는 카드가 있고 장착했을 때 캐릭터의 능력치가 올라가는 컨텐츠였습니다. 그리고 클럽 게시판을 만든 기억이 납니다. 클럽마다 자유롭게 게시물을 작성할 수 있는 게시판이 있고 클럽원 등급별 권한(공지, 삭제, 수정 등)과 댓글, 좋아요 등의 기능이 있었습니다. 이 두가지 컨텐츠 작업을 하면서 DB(MSSSQL)의 테이블 설계와 관련된 클러스터드/넌클러스터드 인덱스 개념과 실행계획 등을 학습하고 활용할 수 있는 아주 좋은 기회를 가졌었습니다.

무난한 듯 무난하지 않은 1년차를 보내나 싶었는데, 7월 쯤 되었을 때 조직개편이 있었습니다. 저희 팀내 파트별 인원수가 대폭 감소되었으며 서버 파트는 경력 10년 이상인 두 분(한 분은 팀장님)과 경력 5년인 제 사수분이 모두 파견과 퇴사로 인해 저 혼자 남게 되었습니다. 단기간 특강을 듣는 듯이 엄청나게 많은 인수인계를 받고 반년 가까이 된 신입이 서버의 모든 업무를 도맡아 수행하기 시작했습니다. 게임 컨텐츠 개발은 물론이고 SVN과 허드슨을 통한 버전(월별 패치)별 그리고 Trunk 소스코드 관리, 라이브 DB 패치를 위한 형상관리용 DB 인스턴스 관리와 기획자가 작업할 개발용 DB 인스턴스 관리, QA 업무 진행을 위한 QA 서버 세팅과 발생되는 서버 이슈 대응, 피 말리는 라이브 패치(DB 패치 스크립트 적용 등 직접 수행), 각종 CS와 라이브 이슈 대응 등 전반적인 서버 업무를 수행했습니다. 이처럼 연차에 비해 일반적이지 않은 경험을 갖고 있는 것이 저의 강점 중 하나입니다.

서버의 여러 업무가 익숙해지기도 전, 9월 쯤에 IDC 이전을 하게 됐습니다. 팀에서 진행하는 프로젝트는 총 3개였으며 한국 서비스(AWS), 중국 서비스(IDC, 클라우드 서비스), 스팀 서비스(AWS)가 있었고 이전을 하게 된 프로젝트가 중국 서비스였습니다. 이 작업은 제가 감당하기 어려웠던 관계로 파견을 나가셨던 (전) 팀장님의 특강을 받아 수행했습니다. 이 때 서버의 로드 밸런싱과 내부 세팅에 대해서 구체적으로 알게 되었습니다.

IDC 이전을 겨우 끝냈을 무렵, 어디서 감히 쉴 생각을 하냐는 듯이 스마일게이트 PC방 사업 SDK 연동 작업을 하게 되었습니다. 단지 dll 파일로부터 import한 여러 함수들을 필요에 따라 호출하는 간단한 작업이지만 그 때 당시의 저에겐 꽤 어려운 일이었습니다. 서버 구조를 정확하게 파악하고 SDK를 연동시켜야 하기 때문에 엔진부분까지 파악해야만 했습니다. 여러 네트워크 입출력과 동기화 관련한 윈도우 API부터 공부해야 진행이 가능했기 때문에 이 때 [윈도우 시스템 프로그램을 구현하는 기술]이라는 서적을 붙들고 회사에서는 소스파악을, 퇴근 후 그리고 주말에는 카페나 독서실에서 공부를 했습니다. 다행스럽게도 제가 맡은 프로젝트만 SDK 연동 작업을 한게 아니고 회사 내 여러 프로젝트들이 진행하였는데 그 중에 저의 프로젝트가 가장 나중에 QA 진행과 라이브 적용 작업을 하게 되어서 시간을 조금 벌 수 있었습니다. (신입인 저를 위해 이처럼 일정 조율해주신 PM님 덕분이라고 생각합니다.) 입사 때부터 네트워크 및 동기화 프로그래밍에 무지한 것은 아니었지만 부실했던 이론과 개념, 윈도우 API 사용법에 대해 탄탄히 다질 수 있는 좋은 기회였습니다. 그렇게 1달 가량의 지독한 공부와 소스파악, 1~2주 동안의 실제 연동 작업을 통해 (물론 이 작업들에만 매진한 것은 아니고 월별 패치와 라이브 이슈 대응 등을 같이 진행하였습니다.) 마침내 기존의 PC방 연동 서버(별개의 전용 프로세스)를 반쯤 뜯어 고쳐서 새로운 SDK 연동 작업에 성공했습니다. 이 때 윈도우즈 시스템 프로그래밍 실력과 지식 수준을 많이 향상 시킬 수 있었고 서버 내부 구조에 대해 좀 더 자세히 알 수 있었습니다.

그렇게 야근하지 않은 날이 손꼽을 정도로 신입 1년차를 화려하게 보냈습니다. (야근을 많이, 잘 한다고 말씀드리기 보다는 정말 많은 일들을 했다는 것을 강조하고 싶습니다.) 위 내용들은 묵직한 몇 개의 일이지만 이것들 외에 정말 수없이 많은 일들을 해왔고 이것들이 서버 프로그래머로서 저의 능력을 비약적으로 발전시켜 주었습니다. 이걸 객관적으로 증명하고자 한다면 2년차 연봉 협상 때 사내 최고의 연봉 상승률 적용과 최고 금액의 인센티브를 받았다고 말씀드릴 수 있습니다. 처음부터 특출난 프로그래머는 아니었지만 저만의 특출난 직업 정신과 열정으로 이룰 수 있지 않았나 싶습니다.

여기서 끝나지 않습니다. 이제 겨우 1년차 때 일들을 주저리 늘어놓은 것 뿐입니다. 2년차 때는 1년차 때에 비해 정말 수월하게 직장 생활을 한 것은 사실이지만 또 한번의 커다란 성장이 있었습니다. (2년차에는 야근하는 날이 엄청 줄었습니다. 반대로 손꼽을 정도로 적었습니다. 52시간 근무제도 있었지만 전반적인 업무 처리 능력이 좋아져서 그런 것 같습니다.) 그리고 다음 설명으로 저의 기술적 지식 수준을 짐작하시는데 도움이 되실 것이라고 생각합니다.

크래쉬 이슈입니다. 프로젝트 중에서 여러 서버(프로세스)들이 있는데 그 중에 메인 서버에서 크래쉬가 발생하는 것입니다. 제가 실질적으로 인지하기 시작한 시점은 2017년 12월이었고 발생 빈도는 1달에 0~3회 가량 발생했습니다. 그리고 나중에 (전) 팀장님으로부터 들은 내용으로는 예전부터 그 이슈가 있었다고 합니다. 크래쉬의 원인은 ACCESS_VIOLATION이었으며 누가 봐도 메모리 접근에 문제가 있다고 볼 수 있습니다. 단순한 크래쉬 이슈면 컨텐츠 코드를 분석해서 수정이 가능했겠지만 죽는 위치가 여러 곳이었습니다. 예를 들어 A, B, C, D, E의 위치가 있다면 A에서 3번, B에서 1번, C에서 2번, D에서 1번.. 이런 식이었습니다. 그리고 메인 서버에서 게임 컨텐츠 데이터를 독점적으로 처리하는 단일 메인 스레드에서만 크래쉬가 발생하는 것입니다. 마치 다중 스레드의 데이터 처리에 있어서 동기화 문제로 인해 발생한 듯 하지만 단일 스레드에서 발생한다는 것이 어떻게 보면 이것도 나름 골머리를 앓게 하지 않았나 싶습니다. 그리고 더욱 어처구니 없는 것은 stl map의 find 함수 내부에서 죽는 경우도 꽤 있었다는 것입니다. map의 find에서 value를 참조하지 않기 때문에 처음 크래쉬 이슈를 접했을 때 map의 내부적 결함으로 이슈를 처리했었습니다. (슬프게도 당시 이 이슈를 같이 봐줄 사수도 없었습니다.) 그래서 이 크래쉬 이슈를 실질적으로 봉착하는 시점도 늦게 되지 않았나 싶습니다.

이 크래쉬 이슈는 올해 초 쯤에 사업쪽으로도 공유되었습니다. 하지만 서버 인력이 저 혼자였고 월별 패치와 라이브 서비스를 해야 하기 때문에 그 이슈를 안고 가기로 결정되었습니다. (사실 제가 맡은 프로젝트는 사내에서 그렇게 중요한 프로젝트는 아니었습니다. 그래서 조직개편으로 규모를 축소한 것이라고 생각합니다.) 하지만 한 달에 최소 한 번씩 제 멘탈을 망가뜨리는 크래쉬를 두고 볼 수만은 없었습니다. 그래서 사업적으로 결정난 그 이슈를 해결해 보겠다 작정하고 비공식적으로 일을 착수했습니다. 그래서 처음 크래쉬 덤프를 열어 보았는데 비주얼 스튜디오로는 열리지 않았습니다. 정확히는 콜스택과 간단한 예외 정보만 덩그러니 나오고 디버깅할 때처럼 코드를 보여주지 않았습니다. (위 설명에서 죽는 위치에 대한 내용은 당시 콜스택만 보고 파악한 것입니다.) WinDbg로 열어보았습니다. 도대체 무슨 내용인지 알 턱이 없었습니다. 마찬가지로 소스코드를 보여주지 않았습니다. 구글링을 해봤지만 명쾌한 사용법을 알려주는 곳은 없었으며 MSDN의 문서를 보고 따라하기에는 터무니없이 양이 방대하고 어려웠습니다.

그래서 그(?)쪽에 대한 지식부터 습득해야 한다는 판단을 했습니다. (물론 크래쉬 이슈를 해결하는 취지가 컸지만 제 실력 향상을 위한 의도도 상당히 컸습니다.) 해결 방법을 모색했고 고급 디버깅 기술이 필요했으며 리버스 엔지니어링을 공부해야 한다는 결론이 나왔습니다. (흔히 리버스 엔지니어링이라 하면 기계어 코드를 디스어셈블링하는 것을 생각하는데 그것도 맞지만 프로그램의 동작 원리를 파악하는데 초점을 두었습니다.) 그리고 [윈도우 실행 파일 구조와 원리로 배우는 리버스 엔지니어링] (한빛미디어, 저자 이호동) 서적을 구매했습니다. 2권 합쳐서 약 2천 페이지가 넘는 방대한 분량이었습니다. 올해 2월부터 퇴근한 후와 주말에 카페나 독서실에서 노트북을 켜놓고 공부하기 시작했습니다. 1권은 PE 파일 구조에 대한 파악과 직접 헥사코드로 확인하는 작업을 주로 했습니다. 그리고 여러 섹션들의 실질적으로 사용되는 방식(예를 들면 어떤 방식로 dll 암시적, 명시적, 지연된 로드를 하며 dll이 내보낸 데이터와 함수를 어떻게 접근하고 사용하는지 등)을 학습했습니다. 2권은 타이틀이 직접 디버거를 구현하는 내용인지라 정말 핵심적인 내용들을 배울 수 있었습니다. 어셈블리어부터 시작해서 코드 섹션 분석, 32bit와 64bit의 스택 프레임 구조와 동작 방식, 기계어를 디스어셈블링하기 위한 PDB 파일 활용, 아니 그 전에 PDB 파일 내부 구조 또한 분석하는 챕터도 있습니다. 그리고 32bit와 64bit의 예외 처리(SEH) 개념과 방식, 메모리 보호 등을 공부했습니다. (마지막 챕터가 디버거 구현이지만 그건 목적이 아닌지라 스킵했습니다.)

그렇게 2월부터 8월 중순까지 약 7개월 가량 열심히 공부했습니다. 도중에 크래쉬가 간간이 발생했지만 어느정도 공부를 해서 해결해야 한다는 위안을 삼으며 버텨내었습니다. 공부를 마칠 때 쯤 또 한번 조직개편이 있었습니다. 저희 팀이 다른 프로젝트의 팀으로 합병되면서 프로젝트는 다르지만 같은 팀으로 배정되는 것이었습니다. 그러면서 6년차 사수도 생기게 되었고 이 크래쉬 이슈를 같이 보게 되었습니다. 사실 사수분도 처음에 이 크래쉬 이슈에 관심이 많았지만 해야 할 일들이 많은 관계로 적극적으로 작업하지는 못했습니다. 여기서 언급하고 싶은 것은 사수분이 먼저 왜 비주얼 스튜디오에서 소스코드를 보여주지 않느냐로 시작한 의문점이 크래쉬 이슈를 해결하는 발판이 되었다는 것입니다. (이 부분도 크래쉬 이슈를 해결하는데 있어서 크게 작용한 것은 사실입니다.) 그 의문점으로부터 비주얼 스튜디오 C/C++ 옵션에서 Debug Information Format이 None으로 세팅되어 코드 관련 (정확히는 변수와 함수 등 관련된 심볼 정보) 정보를 생성하는 부분이 누락되어 있음을 알았고 /Zi 옵션으로 세팅하여 본격적으로 크래쉬 덤프를 토대로 분석을 시작했습니다. (이 외에도 해당 서적에 비주얼 스튜디오의 여러 옵션들에 대한 설명이 들어 있습니다.)

약 15개 가량의 덤프파일을 분석했습니다. 소스코드로 열 수 없는 덤프가 대다수(10개 정도) 였지만 위 /Zi 옵션을 설정한 이후 남는 덤프 분석을 토대로 어느정도 정확한 추측이 가능했습니다. 확실히 리버싱 지식 기반으로 어셈블리 코드까지 보면서 고급 디버깅을 하는 것은 이것을 모르고 하는 디버깅과 차원이 다르다는 것을 느꼈습니다. ACCESS_VIOLATION을 일으키는 포인터의 출처를 추적하는데 용이했고 왜 map의 find 내부에서 죽는지도 증명해냈기 때문입니다. 이유는 이렇습니다. 어떤 클래스 A에 map 자료형을 갖는 멤버 변수가 있습니다. 그런데 그 클래스의 인스턴스가 소멸자를 호출했다면 그 멤버 변수인 map도 소멸자가 호출될 것입니다. map 내부는 트리 구조(레드블랙트리)로 되어 있기 때문에 노드로 Key와 Value가 관리되며 find 함수를 호출하면 그 노드들을 그 트리 검색 방식으로 탐색할 것입니다. 그런데 소멸자가 호출된 map 노드들의 멤버에 접근 하는 것은 흔히 말해 undefined 행위입니다. 지금 기억나는 것 중 하나는 _Tree 내부의 find -> lower_bound -> _Lbound 콜스택 상태에서 _Tree_node 멤버 중에 5번 째로 있는 _Isnil를 참조하다가 죽은게 있습니다. _Tree_node를 가리키는 노드 포인터의 값이 NULL이 었고 NULL 기준으로 25바이트(1~3번째는 _Left, _Parent, _Right인 노드 포인터(각 8바이트)와 4번째는 레드/블랙을 나타내는 _Color인 char형(1바이트)으로 총 25바이트 입니다.) 오프셋으로 주소값을 참조한 것입니다. (실제로 _Isnil 멤버를 참조하기 위한 명령어 부근에서 0x19 메모리 주소에 접근하였다는 예외 정보를 덤프파일에서 확인했습니다.) 이러한 분석을 토대로 클래스 A의 인스턴스는 이미 소멸자가 호출된 것으로 판단할 수 있습니다. map find 내부에서 죽는 경우 외에도 여러 덤프를 분석한 결과, 그 A라는 클래스의 인스턴스가 소멸자가 호출된 포인터임을 증명해 냈습니다. 그리고 증명 도중에 이런 저런 얘기가 오고 갔는데 중요한 몇몇 내용은 이렇습니다. 어떤 클래스 A 내부에 클래스 B 포인터 멤버 변수가 있는데 A 클래스 인스턴스가 소멸자를 호출할 때 소멸자에서 B 포인터 멤버 변수를 NULL로 세팅합니다. 그리고 A 포인터가 dangling 포인터가 된 상태에서 B 포인터로 접근하고 B 포인터를 통해 B의 멤버 함수를 호출해도 그 멤버 함수 호출(정확히는 IP(Instruction Pointer)가 B의 멤버 함수로 넘어가는 과정)은 정상적으로 이루어 집니다. 다만 B 클래스가 상속관계가 없는 관계로 가상 함수 테이블을 먼저 참조하지 않아서 단순히 thiscall 방식에 의해 NULL이 this로 넘겨지고 B의 그 멤버 함수는 링크 타임에 이미 결정된 주소값이므로 호출이 된다는 것입니다. (결론은 상속 관계가 없고 NULL값을 갖는 클래스 인스턴스의 멤버 함수 호출은 호출 자체가 정상적으로 동작한다는 것입니다. 죽는 시점은 멤버 함수 내부에서 this가 NULL이므로 그 인스턴스의 멤버 변수를 NULL에 대한 오프셋으로 접근을 하다가 죽을 것입니다.) 그리고 ACCESS_VIOLATION이 발생되는 시점은 유효하지 않은 주소값 자체를 사용(ex 포인터 연산 등)할 때가 아닌 메모리 영역으로 데이터 읽기/쓰기 시도를 할 때 예외가 발생된다는 점입니다. 이러한 내용들을 바탕으로 앞서 언급한 A라는 클래스의 인스턴스가 dangling 포인터가 된다는 것을 증명해 냈습니다. (증명은 사수분께 했습니다.)

A 클래스는 사실 유저 데이터 일부를 보관하는 클래스입니다. 그리고 dangling 포인터가 되는 부분을 추적하기 위해서 봐야할 부분이 로그인/로그아웃에 의한 A 클래스의 생성과 삭제 부분일 것입니다. (뜬금없겠지만 아쉽게도 오브젝트풀을 사용하지 않고 있습니다.) 메인 스레드는 로그인/로그아웃 과정에 따라 A 인스턴스들을 여러 map들에 나누어 관리합니다. 본격적인 프로파일링을 위해 A 인스턴스를 탐색해서 반환하는 함수들 로직에 A 인스턴스가 유효한지 검사하는 부분을 추가했습니다. 유효하지 않을 경우 추적에 용이한 데이터(유저 식별자, 발생 날짜, 소멸자가 호출된 부분을 추적하기 위한 식별자 등)를 텍스트파일에 로그로 남기고 map에서 제거하도록 했습니다. 그런데 하나 난해한 점이 그 함수들이 메인 스레드가 사용하는 수많은 함수들이 유저 데이터를 찾기 위해서 사용한다는 것입니다. 즉 dangling 포인터가 발견된 시점의 콜스택이 필요하다는 것입니다. 프로그램 실행 중에 프로그래머가 인지하기 쉬운 콜스택 정보를 보려면 PDB 파일의 심볼 정보들을 로드해서 추적하는 방법이 있습니다. 하지만 PDB 파일은 개발망에서 빼낼 수 없을 뿐더러 PDB 파일을 프로그램에 로드해야 하는 상당한 추가 작업과 비효율성, 어려움이 동반됩니다. 그래서 비록 16진수로 이루어진 값이지만 스레드가 실행 중 특정 시점의 콜스택 함수들의 시작 주소값들을 추출하도록 윈도우 전용 API를 사용했습니다. 그 16진수로 이루어진 주소값을 실행파일 빌드 당시의 map파일에서 참조하여 추적할 계획이었습니다. 그런데 또 하나 문제가 발생한 것이 사용한 윈도우 API 함수가 32bit 플랫폼(이하 32bit)에서만 정상 동작을 하는 것이었습니다. (제가 담당하고 있는 프로젝트는 64bit 플랫폼(이하 64bit)입니다. 실제로 출력되는 주소값을 map파일에서 검색할 수 없었습니다.) 그래서 앞서 언급한 서적에서 배운 내용을 토대로 다른 방법을 찾아 적용했습니다. 64bit는 32bit와 다르게 .pdata 섹션이 존재하고 프로그램이 로드될 때 그 정보도 같이 로드합니다. 64bit 전용 예외처리를 위한 데이터 영역이며 프로그램에서 사용하는 모든 함수들과 블럭에 대한 정보가 (특정 구조체 배열로) 들어가 있습니다. 그 정보 중에 함수의 시작 RVA와 끝 RVA가 있습니다. 여기서 특정 윈도우 API 함수를 사용하여 콜스택 시점의 주소값들을 추출하고 또 다른 특정 윈도우 API를 사용해서 그 주소값이 포함되어 있는 함수의 정보를 .pdada 섹션으로부터 추출합니다. 그 정보에서 함수 시작 RVA에 현재 실행파일 이미지가 로드되어 있는 베이스 주소값을 더하면 실제 함수 주소를 추출할 수 있습니다. (실제 이 방식으로 map파일에서 검색이 가능했습니다. 그리고 다행스럽게도 프로젝트의 Randomized Base Address 옵션이 사용되지 않는 관계로 주소값 계산이 수월했습니다.) 이렇게 dangling 포인터 추적을 위한 프로파일링 작업이 진행되었고 실제로 추적하는데에 많은 도움이 되었습니다.

이야기가 너무 길어지는 것 같아서 이후 프로파일링 과정은 생략하고 어떻게 dangling 포인터가 생성되는지 간단히 설명하고 마무리 하겠습니다. 문제가 된 제일 근본적인 원인은 그 유저 데이터를 여러 map에 관리를 하는데 제대로 관리하지 못하는 것이었습니다. 로그아웃 시점에 유저 데이터들이 있는 모든 map에서 A 클래스의 포인터를 제거하지 않는 경우도 있었습니다. 또한 말도 안되는 것 같지만 힙매니저의 힙 chunk 관리 정책(fragmentation을 최소화하기 위한)에 의해 dangling으로 map에 남아 있던 A 클래스의 인스턴스가 프로그래머의 의도와 다르게 살아나는 경우(garbage collector가 없는 환경에서 발생하는 ABA problem으로 알고 있습니다.)도 있었습니다. (이로 인해서 B라는 map에 절대 dangling 포인터가 남을 수 없는 로직임에도 불구하고 이와 같은 경우로 발생할 수 있다는 것 또한 증명해 냈습니다.) 이렇게 하나 하나 차근 차근 분석하고 추적하여 dangling 포인터를 잡아낼 수 있었으며 긴 여정 끝에 현재 몇 개월 째 크래쉬 없이 잘 서비스하고 있습니다.

지금까지 작성한 내용만 보면 디버깅에만 몰두한 프로그래머로 보이겠지만 사실 그렇지만은 않습니다. 고급 디버깅 내용은 크래쉬 이슈 해결과 저의 실력을 성장시키기 위한 최근 가장 열정적인 저의 모습을 보여드리고자 구체적으로 작성하였습니다. 시스템 프로그래머이자 엔지니어로서 최고의 서버 엔진을 만드는 것이 요즘 목표이며 아직 진행 중이라 부족하겠지만 저의 깃헙에 있는 포트폴리오를 보시면 어떤 것들에 관심이 있는지 무엇을 하고 싶은지 알 수 있을 것입니다.

긴 글 읽어 주셔서 감사합니다. 
